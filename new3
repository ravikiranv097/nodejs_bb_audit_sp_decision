'use strict';

/* ================= IMPORTS ================= */

const fs = require('fs');
const path = require('path');
const xlsx = require('xlsx');
const axios = require('axios');
const puppeteer = require('puppeteer');
const officegen = require('officegen');
const winston = require('winston');
require('dotenv').config();

/* ================= CONFIG ================= */

const INPUT_DIR = path.join(__dirname, 'input_files');
const OUTPUT_DIR = path.join(__dirname, 'output_files');
const LOG_DIR = path.join(OUTPUT_DIR, 'logs');
const DOC_DIR = path.join(OUTPUT_DIR, 'doc');

const INPUT_XLSX = path.join(INPUT_DIR, 'SP_Decision_Sheet_Dummy.xlsx');

const HAS_ACCESS_PNG_DIR = path.join(OUTPUT_DIR, 'png/has_access');
const NO_ACCESS_PNG_DIR = path.join(OUTPUT_DIR, 'png/no_access');

const ACCESS_OUTPUT_CSV = path.join(OUTPUT_DIR, 'access_results.csv');
const NO_ACCESS_OUTPUT_CSV = path.join(OUTPUT_DIR, 'no_access_results.csv');

const BASE_URL = process.env.BB_URL?.replace(/\/+$/, '');
const USERNAME = process.env.BB_USERNAME;
const PASSWORD = process.env.BB_AUDIT_PWD;

if (!BASE_URL || !USERNAME || !PASSWORD) {
  console.error('âŒ Missing Bitbucket credentials');
  process.exit(1);
}

/* ================= UTILS ================= */

const ensureDir = d => !fs.existsSync(d) && fs.mkdirSync(d, { recursive: true });
const trim = v => String(v || '').trim();
const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));

/* ===== IST TIMESTAMPS ===== */

function tsIST() {
  return new Intl.DateTimeFormat('en-IN', {
    timeZone: 'Asia/Kolkata',
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
    hour12: false
  }).format(new Date()).replace(',', '');
}

function safeTsIST() {
  return tsIST().replace(/[^\d]/g, '-');
}

/* ===== PROJECT KEY EXTRACTION ===== */

function extractProjectKey(entitlement) {
  if (!entitlement) return '';
  const right = entitlement.split(':')[1];
  return right ? right.split('-')[0].trim() : '';
}

/* ===== DIRECTORIES ===== */

ensureDir(OUTPUT_DIR);
ensureDir(LOG_DIR);
ensureDir(DOC_DIR);
ensureDir(HAS_ACCESS_PNG_DIR);
ensureDir(NO_ACCESS_PNG_DIR);

/* ================= LOGGER ================= */

const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.timestamp({ format: () => tsIST() }),
  transports: [
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.printf(
          ({ timestamp, level, message }) =>
            `${timestamp} [${level}] ${message}`
        )
      )
    }),
    new winston.transports.File({
      filename: path.join(LOG_DIR, 'audit-info.log'),
      level: 'info'
    }),
    new winston.transports.File({
      filename: path.join(LOG_DIR, 'audit-error.log'),
      level: 'error'
    })
  ]
});

/* ================= BITBUCKET CLIENT ================= */

class BitbucketClient {
  constructor() {
    this.queue = [];
    this.active = 0;
    this.MAX = 5;
    this.RETRIES = 3;
  }

  async get(url, attempt = 1) {
    return new Promise(resolve => {
      this.queue.push({ url, attempt, resolve });
      this._next();
    });
  }

  async _next() {
    if (this.active >= this.MAX || !this.queue.length) return;
    const job = this.queue.shift();
    this.active++;

    try {
      const r = await axios.get(job.url, {
        auth: { username: USERNAME, password: PASSWORD }
      });
      job.resolve(r.data);
    } catch {
      logger.error(`API error | ${job.url} | attempt=${job.attempt}`);
      if (job.attempt < this.RETRIES) {
        logger.warn(`Retrying API (${job.attempt + 1}/${this.RETRIES})`);
        setTimeout(
          () => this.queue.push({ ...job, attempt: job.attempt + 1 }),
          500 * job.attempt
        );
      } else {
        job.resolve(null);
      }
    } finally {
      this.active--;
      this._next();
    }
  }
}

/* ================= PERMISSION RESOLVER ================= */

class PermissionResolver {
  constructor(bb) {
    this.bb = bb;
    this.groupCache = new Map();
  }

  async inGroup(group, user) {
    const key = `${group}:${user}`;
    if (this.groupCache.has(key)) return this.groupCache.get(key);

    const url =
      `${BASE_URL}/rest/api/1.0/admin/groups/more-members?context=${encodeURIComponent(group)}&filter=${encodeURIComponent(user)}`;
    const d = await this.bb.get(url);
    const ok = d?.values?.length > 0;
    this.groupCache.set(key, ok);
    return ok;
  }

  best(perms) {
    const p = { ADMIN: 3, WRITE: 2, READ: 1 };
    return perms.sort((a, b) => p[b] - p[a])[0];
  }

  async checkProject(project, user) {
    const apiCalls = [];

    let url =
      `${BASE_URL}/rest/api/1.0/projects/${encodeURIComponent(project)}/permissions/users?filter=${encodeURIComponent(user)}`;
    apiCalls.push(url);
    let d = await this.bb.get(url);

    if (d?.values?.length)
      return { hasAccess: true, level: this.best(d.values.map(v => v.permission)), source: 'PROJECT_USER', apiCalls };

    url =
      `${BASE_URL}/rest/api/1.0/projects/${encodeURIComponent(project)}/permissions/groups`;
    apiCalls.push(url);
    d = await this.bb.get(url);

    if (d?.values) {
      for (const g of d.values) {
        if (await this.inGroup(g.group.name, user))
          return { hasAccess: true, level: g.permission, source: 'PROJECT_GROUP', apiCalls };
      }
    }

    url =
      `${BASE_URL}/rest/api/1.0/projects/${encodeURIComponent(project)}/repos?limit=1000`;
    apiCalls.push(url);
    const repos = await this.bb.get(url);

    if (!repos?.values)
      return { hasAccess: false, apiCalls };

    const results = (await Promise.all(
      repos.values.map(r => this.checkRepo(project, r.slug, user, apiCalls))
    )).filter(Boolean);

    if (!results.length)
      return { hasAccess: false, apiCalls };

    return {
      hasAccess: true,
      level: this.best(results.map(r => r.level)),
      source: results[0].source,
      repo: results[0].repo,
      apiCalls
    };
  }

  async checkRepo(project, repo, user, apiCalls) {
    let url =
      `${BASE_URL}/rest/api/1.0/projects/${encodeURIComponent(project)}/repos/${encodeURIComponent(repo)}/permissions/users?filter=${encodeURIComponent(user)}`;
    apiCalls.push(url);
    let d = await this.bb.get(url);

    if (d?.values?.length)
      return { level: this.best(d.values.map(v => v.permission)), source: 'REPO_USER', repo };

    url =
      `${BASE_URL}/rest/api/1.0/projects/${encodeURIComponent(project)}/repos/${encodeURIComponent(repo)}/permissions/groups`;
    apiCalls.push(url);
    d = await this.bb.get(url);

    if (d?.values) {
      for (const g of d.values) {
        if (await this.inGroup(g.group.name, user))
          return { level: g.permission, source: 'REPO_GROUP', repo };
      }
    }
    return null;
  }
}

/* ================= SCREENSHOT HTML ================= */

function buildEvidenceHtml({
  user, accountId, project, active,
  hasAccess, level, source, apiCalls, repo
}) {
  return `
<html>
<head>
<style>
body { font-family: Arial; background:#fff; }
table { border-collapse: collapse; }
td { border:1px solid #999; padding:6px 12px; vertical-align:top; }
td.label { font-weight:bold; background:#f2f2f2; white-space:nowrap; }
.yes { color:green; font-weight:bold; }
.no { color:red; font-weight:bold; }
pre { margin:0; white-space:pre-wrap; word-break:break-word; }
</style>
</head>
<body>
<h2>Bitbucket Access Evidence</h2>
<table>
<tr><td class="label">Username</td><td>${user}</td></tr>
<tr><td class="label">Account ID</td><td>${accountId}</td></tr>
<tr><td class="label">Project Code</td><td>${project}</td></tr>
<tr><td class="label">Timestamp (IST)</td><td>${tsIST()}</td></tr>
<tr><td class="label">Active</td><td>${active}</td></tr>
<tr>
  <td class="label">Has Access</td>
  <td class="${hasAccess ? 'yes' : 'no'}">${hasAccess ? 'YES' : 'NO'}</td>
</tr>
<tr><td class="label">Permission Level</td><td>${level || '-'}</td></tr>
<tr><td class="label">Permission Source</td><td>${source || '-'}</td></tr>
<tr><td class="label">Repository</td><td>${repo || '-'}</td></tr>
<tr>
  <td class="label">API Details</td>
  <td><pre>${apiCalls.join('\n')}</pre></td>
</tr>
</table>
</body>
</html>`;
}

/* ================= DOCX ================= */

async function generateDoc(imageDir, outputName) {
  const images = fs.readdirSync(imageDir).filter(f => f.endsWith('.png'));
  if (!images.length) return;

  const docx = officegen('docx');
  docx.createP().addText(outputName.replace('.docx',''), { bold:true });

  images.forEach((img, i) => {
    docx.createP().addImage(path.join(imageDir, img));
    if (i < images.length - 1)
      docx.createP().addText('', { pageBreakBefore:true });
  });

  const out = fs.createWriteStream(path.join(DOC_DIR, outputName));
  docx.generate(out);
}

/* ================= MAIN ================= */

(async function main() {
  logger.info('Bitbucket audit started');

  const bb = new BitbucketClient();
  const resolver = new PermissionResolver(bb);

  const wb = xlsx.readFile(INPUT_XLSX);
  const ws = wb.Sheets[wb.SheetNames[0]];
  const rows = xlsx.utils.sheet_to_json(ws, { defval: '' })
    .filter(r => trim(r.Decision) === 'Revoked');

  logger.info(`Loaded ${rows.length} revoked rows`);

  fs.writeFileSync(ACCESS_OUTPUT_CSV, 'User,Project,Status,Level,Source,Repo,Timestamp,Screenshot\n');
  fs.writeFileSync(NO_ACCESS_OUTPUT_CSV, 'User,Project,Status,Level,Source,Repo,Timestamp,Screenshot\n');

  const browser = await puppeteer.launch({
    headless: true,
    args: ['--no-sandbox', '--disable-setuid-sandbox']
  });

  const page = await browser.newPage();
  await page.setDefaultNavigationTimeout(0);
  await page.setDefaultTimeout(0);

  for (let i = 0; i < rows.length; i++) {
    const r = rows[i];
    const user = trim(r['User SSO']);
    const accountId = trim(r['Account ID']);
    const active = trim(r['Active'] || 'N/A');
    const project = extractProjectKey(r['Entitlement Description']);

    logger.info(`Checking | user=${user} | project=${project} | ${i+1}/${rows.length}`);

    const res = await resolver.checkProject(project, user);
    const status = res.hasAccess ? 'HAS_ACCESS' : 'NO_ACCESS';

    const pngPath = path.join(
      res.hasAccess ? HAS_ACCESS_PNG_DIR : NO_ACCESS_PNG_DIR,
      `${user}_${project}_${safeTsIST()}.png`
    );

    const html = buildEvidenceHtml({
      user,
      accountId,
      project,
      active,
      hasAccess: res.hasAccess,
      level: res.level,
      source: res.source,
      repo: res.repo,
      apiCalls: res.apiCalls || []
    });

    await page.setContent(html);
    await sleep(100);
    await page.screenshot({ path: pngPath });

    fs.appendFileSync(
      res.hasAccess ? ACCESS_OUTPUT_CSV : NO_ACCESS_OUTPUT_CSV,
      `${user},${project},${status},${res.level || ''},${res.source || ''},${res.repo || ''},${tsIST()},${pngPath}\n`
    );
  }

  await browser.close();

  await generateDoc(HAS_ACCESS_PNG_DIR, 'Bitbucket_Has_Access_Report.docx');
  await generateDoc(NO_ACCESS_PNG_DIR, 'Bitbucket_No_Access_Report.docx');

  logger.info('Bitbucket audit completed successfully');
})();
