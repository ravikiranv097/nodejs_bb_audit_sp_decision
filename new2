'use strict';

/* =========================================================
   REQUIRED for corporate Bitbucket SSL inspection
   (same as curl -k)
========================================================= */
process.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';

const fs = require('fs');
const path = require('path');
const xlsx = require('xlsx');
const axios = require('axios');
const puppeteer = require('puppeteer');
require('dotenv').config();
const officegen = require('officegen');

let sharp = null;
try {
  sharp = require('sharp');
} catch {
  console.warn('sharp not installed — PNG trimming skipped');
}

/* ------------------- CONFIG ------------------- */

const INPUT_DIR = path.join(__dirname, 'input_files');
const OUTPUT_DIR = path.join(__dirname, 'output_files');

const INPUT_XLSX = path.join(INPUT_DIR, 'SP_Decision_Sheet_Dummy.xlsx');
const REVOKED_CSV = path.join(OUTPUT_DIR, 'revoked_rows.csv');
const FORMATTED_CSV = path.join(OUTPUT_DIR, 'formatted_revoked_rows.csv');

const ACCESS_OUTPUT_CSV = path.join(OUTPUT_DIR, 'access_check_results.csv');
const NO_ACCESS_OUTPUT_CSV = path.join(OUTPUT_DIR, 'no_access_check_results.csv');

const HAS_ACCESS_PNG_DIR = path.join(OUTPUT_DIR, 'png/has_access');
const NO_ACCESS_PNG_DIR = path.join(OUTPUT_DIR, 'png/no_access');
const DOC_DIR = path.join(OUTPUT_DIR, 'doc');

ensureDir(INPUT_DIR);
ensureDir(OUTPUT_DIR);
ensureDir(HAS_ACCESS_PNG_DIR);
ensureDir(NO_ACCESS_PNG_DIR);
ensureDir(DOC_DIR);

/* ------------------- BITBUCKET CONFIG ------------------- */

const BB_URL_RAW = (process.env.BB_URL || '').trim();
const USERNAME = process.env.BB_USERNAME;
const KEYNAME = process.env.BB_KEYNAME;

if (!BB_URL_RAW || !USERNAME || !KEYNAME) {
  console.error('Missing BB_URL / BB_USERNAME / BB_KEYNAME');
  process.exit(1);
}

let BASE_URL = BB_URL_RAW.replace(/\/+$/g, '');
if (!/^https?:\/\//i.test(BASE_URL)) {
  BASE_URL = 'https://' + BASE_URL;
}

const AUTH = {
  auth: {
    username: USERNAME,
    password: KEYNAME
  }
};

/* ------------------- UTILS ------------------- */

function ensureDir(dir) {
  if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
}

const trim = v => String(v || '').trim();

function csvRow(fields) {
  return fields.map(f => String(f ?? '').replace(/\r?\n/g, ' ')).join(',');
}

function formatTimestamp() {
  return new Date().toISOString().replace('T', ' ').split('.')[0];
}

function formatSafeTimestamp() {
  return new Date().toISOString().replace(/[:T]/g, '-').split('.')[0];
}

async function safeGet(url) {
  try {
    return await axios.get(url, AUTH);
  } catch {
    return null;
  }
}

/* ------------------- ACCESS HELPERS ------------------- */

async function isUserInGroup(groupName, username) {
  const res = await safeGet(
    `${BASE_URL}/rest/api/1.0/admin/groups/more-members?context=${encodeURIComponent(groupName)}`
  );
  return (res?.data?.values || []).some(u => u.name === username);
}

async function hasEffectiveProjectAccess(projectKey, username) {

  // 1️⃣ Project user permission
  let res = await safeGet(
    `${BASE_URL}/rest/api/1.0/projects/${projectKey}/permissions/users?filter=${encodeURIComponent(username)}`
  );
  if (res?.data?.values?.length) return true;

  // 2️⃣ Project group permission
  res = await safeGet(
    `${BASE_URL}/rest/api/1.0/projects/${projectKey}/permissions/groups`
  );
  for (const g of res?.data?.values || []) {
    if (await isUserInGroup(g.group.name, username)) return true;
  }

  // 3️⃣ Repo permissions
  const repos = await safeGet(
    `${BASE_URL}/rest/api/1.0/projects/${projectKey}/repos?limit=1000`
  );

  for (const r of repos?.data?.values || []) {

    // Repo user
    res = await safeGet(
      `${BASE_URL}/rest/api/1.0/projects/${projectKey}/repos/${r.slug}/permissions/users?filter=${encodeURIComponent(username)}`
    );
    if (res?.data?.values?.length) return true;

    // Repo group
    res = await safeGet(
      `${BASE_URL}/rest/api/1.0/projects/${projectKey}/repos/${r.slug}/permissions/groups`
    );
    for (const g of res?.data?.values || []) {
      if (await isUserInGroup(g.group.name, username)) return true;
    }
  }

  return false;
}

/* ------------------- STEP 1 + 2 ------------------- */

function extractRevokedRowsFromXlsx() {

  const workbook = xlsx.readFile(INPUT_XLSX);
  const sheet = workbook.Sheets[workbook.SheetNames[0]];
  const rows = xlsx.utils.sheet_to_json(sheet, { defval: '' });

  const header = Object.keys(rows[0] || {});
  const revoked = rows.filter(r => trim(r['Decision']) === 'Revoked');

  const out = [csvRow(header)];
  revoked.forEach(r => out.push(csvRow(header.map(h => r[h]))));

  fs.writeFileSync(REVOKED_CSV, out.join('\n'));
  return revoked;
}

/* ------------------- STEP 3 ------------------- */

function transformRevokedRowsToFormatted(rows) {

  const header = ['User SSO', 'Account ID', 'Project Key', 'Access Permission', 'Decision'];
  const out = [csvRow(header)];

  for (const r of rows) {
    const user = trim(r['User SSO']);
    const acc = trim(r['Account ID']);
    const ent = trim(r['Entitlement Description']);

    let project = '', perm = '';
    if (ent.includes(':')) {
      const p = ent.split(':')[1].trim().split('-');
      project = p[0];
      perm = p[1] || '';
    }

    out.push(csvRow([user, acc, project, perm, 'Revoked']));
  }

  fs.writeFileSync(FORMATTED_CSV, out.join('\n'));
}

/* ------------------- STEP 4 ------------------- */

async function performAccessCheck() {

  fs.writeFileSync(
    ACCESS_OUTPUT_CSV,
    csvRow(['Username','Account ID','Project Key','Permission','Access','Timestamp','Screenshot']) + '\n'
  );
  fs.writeFileSync(
    NO_ACCESS_OUTPUT_CSV,
    csvRow(['Username','Account ID','Project Key','Permission','Access','Timestamp','Screenshot']) + '\n'
  );

  const rows = fs.readFileSync(FORMATTED_CSV, 'utf8').split(/\r?\n/).filter(Boolean);
  if (rows.length <= 1) return;

  const browser = await puppeteer.launch({ headless: true });
  const page = await browser.newPage();

  for (let i = 1; i < rows.length; i++) {

    const [user, acc, proj, perm] = rows[i].split(',').map(trim);

    const hasAccess = await hasEffectiveProjectAccess(proj, user);
    const ts = formatTimestamp();
    const safeTs = formatSafeTimestamp();

    const html = `
      <pre>
User: ${user}
Project: ${proj}
Access: ${hasAccess ? 'HAS_ACCESS' : 'NO_ACCESS'}
Timestamp: ${ts}
      </pre>`;

    const htmlFile = path.join(OUTPUT_DIR, `${user}_${proj}_${safeTs}.html`);
    fs.writeFileSync(htmlFile, html);

    await page.goto('file://' + htmlFile);

    const png = hasAccess
      ? path.join(HAS_ACCESS_PNG_DIR, `${user}_${proj}_${safeTs}.png`)
      : path.join(NO_ACCESS_PNG_DIR, `${user}_${proj}_${safeTs}.png`);

    await page.screenshot({ path: png, fullPage: true });

    fs.appendFileSync(
      hasAccess ? ACCESS_OUTPUT_CSV : NO_ACCESS_OUTPUT_CSV,
      csvRow([user, acc, proj, perm, hasAccess ? 'HAS_ACCESS' : 'NO_ACCESS', ts, png]) + '\n'
    );
  }

  await browser.close();
}

/* ------------------- DOCX ------------------- */

async function generateDoc(dir, name) {
  const images = fs.readdirSync(dir).filter(f => f.endsWith('.png'));
  if (!images.length) return;

  const docx = officegen('docx');
  const out = fs.createWriteStream(path.join(DOC_DIR, name));

  images.forEach(f => docx.createP().addImage(path.join(dir, f)));
  docx.generate(out);
}

/* ------------------- MAIN ------------------- */

(async () => {
  const revoked = extractRevokedRowsFromXlsx();
  transformRevokedRowsToFormatted(revoked);
  await performAccessCheck();
  await generateDoc(HAS_ACCESS_PNG_DIR, 'Bitbucket_Has_Access_Report.docx');
  await generateDoc(NO_ACCESS_PNG_DIR, 'Bitbucket_No_Access_Report.docx');
})();