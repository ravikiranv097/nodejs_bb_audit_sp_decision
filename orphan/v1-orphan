'use strict';

/* ===================== IMPORTS ===================== */
const fs = require('fs');
const path = require('path');
const xlsx = require('xlsx');
const axios = require('axios');
const puppeteer = require('puppeteer');
const officegen = require('officegen');
const winston = require('winston');
const https = require('https');
require('dotenv').config();

/* ===================== CONFIG ===================== */
const INPUT_DIR = path.join(__dirname, 'input_files');
const OUTPUT_DIR = path.join(__dirname, 'output_files');
const LOG_DIR = path.join(OUTPUT_DIR, 'logs');
const DOC_DIR = path.join(OUTPUT_DIR, 'doc');

const files = fs.readdirSync(INPUT_DIR).filter(f => f.endsWith('.xlsx'));
if (!files.length) throw new Error('No Excel file found');
const INPUT_XLSX = path.join(INPUT_DIR, files[0]);

const HAS_ACCESS_PNG_DIR = path.join(OUTPUT_DIR, 'png/has_access');
const NO_ACCESS_PNG_DIR = path.join(OUTPUT_DIR, 'png/no_access');

const ACCESS_OUTPUT_CSV = path.join(OUTPUT_DIR, 'access_check_results.csv');
const NO_ACCESS_OUTPUT_CSV = path.join(OUTPUT_DIR, 'no_access_check_results.csv');

const BASE_URL = process.env.BB_URL?.replace(/\/+$/, '');
const USERNAME = process.env.BB_USERNAME;
const PWORD = process.env.BB_AUDIT_PWD;

if (!BASE_URL || !USERNAME || !PWORD) {
  console.error('Missing Bitbucket credentials');
  process.exit(1);
}

/* ===================== UTILS ===================== */
const ensureDir = d => !fs.existsSync(d) && fs.mkdirSync(d, { recursive: true });
const trim = v => String(v || '').trim();
const sleep = ms => new Promise(r => setTimeout(r, ms));

function tsIST() {
  return new Intl.DateTimeFormat('en-IN', {
    timeZone: 'Asia/Kolkata',
    year: 'numeric', month: '2-digit', day: '2-digit',
    hour: '2-digit', minute: '2-digit', second: '2-digit',
    hour12: false
  }).format(new Date()).replace(',', '');
}

function safeTsIST() {
  return tsIST().replace(/[^\d]/g, '-');
}

function extractProjectKey(entitlement) {
  if (!entitlement) return '';
  const right = entitlement.split(':')[1];
  return right ? right.split('-')[0].trim() : '';
}

function normalizeSSO(v) {
  return String(v || '').trim().toLowerCase();
}

/* ===================== DIRS ===================== */
[
  OUTPUT_DIR,
  LOG_DIR,
  DOC_DIR,
  HAS_ACCESS_PNG_DIR,
  NO_ACCESS_PNG_DIR
].forEach(ensureDir);

/* ===================== LOGGER ===================== */
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.timestamp({ format: tsIST }),
  transports: [
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.printf(({ timestamp, level, message }) =>
          `${timestamp} [${level}] ${message}`
        )
      )
    }),
    new winston.transports.File({
      filename: path.join(LOG_DIR, 'audit-info.log')
    }),
    new winston.transports.File({
      filename: path.join(LOG_DIR, 'audit-error.log'),
      level: 'error'
    })
  ]
});

/* ===================== BITBUCKET CLIENT ===================== */
class BitbucketClient {
  constructor() {
    this.queue = [];
    this.active = 0;
    this.MAX = 3;

    this.client = axios.create({
      baseURL: BASE_URL,
      timeout: 30000,
      auth: { username: USERNAME, password: PWORD },
      httpsAgent: new https.Agent({
        keepAlive: false,
        rejectUnauthorized: false
      }),
      validateStatus: s => s < 500
    });
  }

  async get(url) {
    return new Promise(resolve => {
      this.queue.push({ url, resolve });
      this._next();
    });
  }

  async _next() {
    if (this.active >= this.MAX || !this.queue.length) return;
    const job = this.queue.shift();
    this.active++;

    try {
      const r = await this.client.get(job.url);
      job.resolve(r.data);
    } catch (err) {
      logger.error(`API error | ${job.url} | ${err.message}`);
      job.resolve(null);
    } finally {
      this.active--;
      this._next();
    }
  }
}

/* ===================== PERMISSION RESOLVER ===================== */
class PermissionResolver {
  constructor(bb) {
    this.bb = bb;
    this.groupCache = new Map();
    this.repoCache = new Map();
  }

  best(perms) {
    const p = { ADMIN: 3, WRITE: 2, READ: 1 };
    return perms.sort((a, b) => (p[b] || 0) - (p[a] || 0))[0];
  }

  async inGroup(group, user) {
    const key = `${group}:${user}`;
    if (this.groupCache.has(key)) return this.groupCache.get(key);

    const url =
      `${BASE_URL}/rest/api/1.0/admin/groups/more-members` +
      `?context=${encodeURIComponent(group)}&filter=${encodeURIComponent(user)}`;

    const d = await this.bb.get(url);
    const ok = d?.values?.length > 0;
    this.groupCache.set(key, ok);
    return ok;
  }

  async getRepos(project) {
    if (this.repoCache.has(project)) return this.repoCache.get(project);
    const url = `${BASE_URL}/rest/api/1.0/projects/${project}/repos?limit=1000`;
    const d = await this.bb.get(url);
    const repos = d?.values || [];
    this.repoCache.set(project, repos);
    return repos;
  }

  async checkProject(project, user) {
    logger.info(`Checking access | user=${user} | project=${project}`);

    const result = {
      project: { matched: false, level: null },
      group: { matched: false, level: null },
      repo: { matched: false, level: null },
      apiEvidence: []
    };

    /* ---- Project User ---- */
    let url = `${BASE_URL}/rest/api/1.0/projects/${project}/permissions/users?filter=${user}`;
    let d = await this.bb.get(url);
    result.apiEvidence.push({ endpoint: url, matched: !!d?.values?.length, values: d?.values || [] });

    if (d?.values?.length) {
      result.project.matched = true;
      result.project.level = this.best(d.values.map(v => v.permission));
    }

    /* ---- Project Groups ---- */
    url = `${BASE_URL}/rest/api/1.0/projects/${project}/permissions/groups`;
    d = await this.bb.get(url);
    result.apiEvidence.push({ endpoint: url, matched: false, values: d?.values || [] });

    for (const g of d?.values || []) {
      if (await this.inGroup(g.group.name, user)) {
        result.group.matched = true;
        result.group.level = g.permission;
      }
    }

    /* ---- Repo Users ---- */
    const repos = await this.getRepos(project);
    for (const r of repos) {
      const ru =
        `${BASE_URL}/rest/api/1.0/projects/${project}/repos/${r.slug}/permissions/users?filter=${user}`;
      const rd = await this.bb.get(ru);
      result.apiEvidence.push({ endpoint: ru, matched: !!rd?.values?.length, values: rd?.values || [] });

      if (rd?.values?.length) {
        result.repo.matched = true;
        result.repo.level = this.best(rd.values.map(v => v.permission));
      }
    }

    const hasAccess =
      result.project.matched ||
      result.group.matched ||
      result.repo.matched;

    const level =
      result.project.level ||
      result.group.level ||
      result.repo.level ||
      'PROJECT_READ';

    logger.info(
      `Result | project=${result.project.matched} | group=${result.group.matched} | repo=${result.repo.matched} | final=${hasAccess}`
    );

    return {
      hasAccess,
      accessCheck: {
        project: result.project.matched,
        group: result.group.matched,
        repo: result.repo.matched
      },
      level,
      source: 'PROJECT_USER',
      apiEvidence: result.apiEvidence
    };
  }
}

/* ===================== HTML ===================== */
function buildEvidenceHtml({ user, accountId, project, hasAccess, level, source, accessCheck, apiEvidence }) {
  return `
<html>
<head>
<style>
body { font-family: Arial; padding: 20px; }
table { border-collapse: collapse; }
td { border: 1px solid #999; padding: 6px 10px; }
td.label { font-weight: bold; background: #f2f2f2; }
.yes { color: green; font-weight: bold; }
.no { color: red; font-weight: bold; }
pre { white-space: pre-wrap; word-break: break-word; }
</style>
</head>
<body>
<h2>Bitbucket Access Evidence</h2>
<table id="evidence-table">
<tr><td class="label">Username</td><td>${user}</td></tr>
<tr><td class="label">Account ID</td><td>${accountId}</td></tr>
<tr><td class="label">Project</td><td>${project}</td></tr>
<tr><td class="label">Timestamp (IST)</td><td>${tsIST()}</td></tr>

<tr>
<td class="label">Access Check</td>
<td>
Project <span class="${accessCheck.project ? 'yes' : 'no'}">${accessCheck.project ? 'Yes' : 'No'}</span><br/>
Group <span class="${accessCheck.group ? 'yes' : 'no'}">${accessCheck.group ? 'Yes' : 'No'}</span><br/>
Repo <span class="${accessCheck.repo ? 'yes' : 'no'}">${accessCheck.repo ? 'Yes' : 'No'}</span>
</td>
</tr>

<tr><td class="label">Has Access</td><td class="${hasAccess ? 'yes' : 'no'}">${hasAccess ? 'Yes' : 'No'}</td></tr>
<tr><td class="label">Permission Level</td><td>${level}</td></tr>
<tr><td class="label">Source</td><td>${source}</td></tr>
<tr><td class="label">API Response</td><td><pre>${JSON.stringify(apiEvidence, null, 2)}</pre></td></tr>
</table>
</body>
</html>`;
}

/* ===================== MAIN ===================== */
(async function main() {
  logger.info('Bitbucket audit started');

  fs.writeFileSync(
    ACCESS_OUTPUT_CSV,
    'Username,Account ID,Project,Access Status,Level,Source,Timestamp (IST),Screenshot\n'
  );
  fs.writeFileSync(
    NO_ACCESS_OUTPUT_CSV,
    'Username,Account ID,Project,Access Status,Level,Source,Timestamp (IST),Screenshot\n'
  );

  const wb = xlsx.readFile(INPUT_XLSX);
  const ws = wb.Sheets[wb.SheetNames[0]];
  const rows = xlsx.utils.sheet_to_json(ws, { defval: '' });

  const seen = new Set();
  const unique = [];

  for (const r of rows) {
    const sso = normalizeSSO(r['User SSO']);
    if (!sso || seen.has(sso)) continue;
    seen.add(sso);
    unique.push(r);
  }

  const targets = unique.filter(r =>
    trim(r['User Status']) === 'Orphan' &&
    trim(r['Decision']) === 'Keep'
  );

  const bb = new BitbucketClient();
  const resolver = new PermissionResolver(bb);

  const browser = await puppeteer.launch({ headless: true });
  const page = await browser.newPage();

  for (const r of targets) {
    const user = trim(r['User SSO']);
    const accountId = trim(r['Account ID']);
    const project = extractProjectKey(r['Entitlement Description']);

    const res = await resolver.checkProject(project, user);

    const html = buildEvidenceHtml({
      user,
      accountId,
      project,
      hasAccess: res.hasAccess,
      level: res.level,
      source: res.source,
      accessCheck: res.accessCheck,
      apiEvidence: res.apiEvidence
    });

    await page.setContent(html, { waitUntil: 'domcontentloaded' });
    await sleep(50);

    const pngPath = path.join(
      res.hasAccess ? HAS_ACCESS_PNG_DIR : NO_ACCESS_PNG_DIR,
      `${user}_${project}_${safeTsIST()}.png`
    );

    const table = await page.$('#evidence-table');
    await table.screenshot({ path: pngPath, padding: 15 });

    fs.appendFileSync(
      res.hasAccess ? ACCESS_OUTPUT_CSV : NO_ACCESS_OUTPUT_CSV,
      [
        user,
        accountId,
        project,
        res.hasAccess ? 'HAS_ACCESS' : 'NO_ACCESS',
        res.level,
        res.source,
        tsIST(),
        pngPath
      ].join(',') + '\n'
    );
  }

  await browser.close();
  logger.info('Bitbucket audit completed successfully');
})();
