'use strict';

/* ================= IMPORTS ================= */

const fs = require('fs');
const path = require('path');
const xlsx = require('xlsx');
const axios = require('axios');
const puppeteer = require('puppeteer');
const officegen = require('officegen');
const winston = require('winston');
require('dotenv').config();

/* ================= CONFIG ================= */

const INPUT_DIR = path.join(__dirname, 'input_files');
const OUTPUT_DIR = path.join(__dirname, 'output_files');
const LOG_DIR = path.join(OUTPUT_DIR, 'logs');
const DOC_DIR = path.join(OUTPUT_DIR, 'doc');

const INPUT_XLSX = path.join(INPUT_DIR, 'Bitbucket_OrphanDecisions_Q32025.xlsx');

const UNIQUE_CSV = path.join(OUTPUT_DIR, 'unique_user_sso_rows.csv');
const EXTRACTED_CSV = path.join(OUTPUT_DIR, 'extracted_data.csv');

const HAS_ACCESS_PNG_DIR = path.join(OUTPUT_DIR, 'png/has_access');
const NO_ACCESS_PNG_DIR = path.join(OUTPUT_DIR, 'png/no_access');

const ACCESS_OUTPUT_CSV = path.join(OUTPUT_DIR, 'access_check_results.csv');
const NO_ACCESS_OUTPUT_CSV = path.join(OUTPUT_DIR, 'no_access_check_results.csv');

const BASE_URL = process.env.BB_URL?.replace(/\/+$/, '');
const USERNAME = process.env.BB_USERNAME;
const PASSWORD = process.env.BB_AUDIT_PWD;

if (!BASE_URL || !USERNAME || !PASSWORD) {
  console.error('❌ Missing Bitbucket credentials');
  process.exit(1);
}

/* ================= UTILS ================= */

const ensureDir = d => !fs.existsSync(d) && fs.mkdirSync(d, { recursive: true });
const trim = v => String(v || '').trim();
const sleep = ms => new Promise(r => setTimeout(r, ms));

function tsIST() {
  return new Intl.DateTimeFormat('en-IN', {
    timeZone: 'Asia/Kolkata',
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
    hour12: false
  }).format(new Date()).replace(',', '');
}

function safeTsIST() {
  return tsIST().replace(/[^\d]/g, '-');
}

/* ================= PROJECT KEY EXTRACTION ================= */
/*
  Expected formats ONLY (from real data):
  - "U : PA-Write"
  - "P : PA-Admin"
  - "P : PB-Write"
*/

function extractProjectKey(entitlement) {
  if (!entitlement) return '';
  const match = entitlement.match(/:\s*([A-Z0-9]+)-/);
  return match ? match[1] : '';
}

/* ================= DIRS ================= */

[
  OUTPUT_DIR,
  LOG_DIR,
  DOC_DIR,
  HAS_ACCESS_PNG_DIR,
  NO_ACCESS_PNG_DIR
].forEach(ensureDir);

/* ================= LOGGER ================= */

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.timestamp({ format: () => tsIST() }),
  transports: [
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.printf(
          ({ timestamp, level, message }) =>
            `${timestamp} [${level}] ${message}`
        )
      )
    }),
    new winston.transports.File({
      filename: path.join(LOG_DIR, 'audit-info.log')
    }),
    new winston.transports.File({
      filename: path.join(LOG_DIR, 'audit-error.log'),
      level: 'error'
    })
  ]
});

/* ================= BITBUCKET CLIENT ================= */

class BitbucketClient {
  constructor() {
    this.queue = [];
    this.active = 0;
    this.MAX = 5;
  }

  async get(url) {
    return new Promise(resolve => {
      this.queue.push({ url, resolve });
      this._next();
    });
  }

  async _next() {
    if (this.active >= this.MAX || !this.queue.length) return;
    const job = this.queue.shift();
    this.active++;

    try {
      const r = await axios.get(job.url, {
        auth: { username: USERNAME, password: PASSWORD }
      });
      job.resolve(r.data);
    } catch {
      logger.error(`API error | ${job.url}`);
      job.resolve(null);
    } finally {
      this.active--;
      this._next();
    }
  }
}

/* ================= PERMISSION RESOLVER ================= */

class PermissionResolver {
  constructor(bb) {
    this.bb = bb;
    this.groupCache = new Map();
    this.repoCache = new Map();
  }

  async inGroup(group, user) {
    const key = `${group}:${user}`;
    if (this.groupCache.has(key)) return this.groupCache.get(key);

    const url =
      `${BASE_URL}/rest/api/1.0/admin/groups/more-members?context=${encodeURIComponent(group)}&filter=${encodeURIComponent(user)}`;
    const d = await this.bb.get(url);
    const ok = d?.values?.length > 0;
    this.groupCache.set(key, ok);
    return ok;
  }

  best(perms) {
    const p = { ADMIN: 3, WRITE: 2, READ: 1 };
    return perms.sort((a, b) => p[b] - p[a])[0];
  }

  async getRepos(project) {
    if (this.repoCache.has(project)) return this.repoCache.get(project);
    const url = `${BASE_URL}/rest/api/1.0/projects/${project}/repos?limit=1000`;
    const d = await this.bb.get(url);
    const repos = d?.values || [];
    this.repoCache.set(project, repos);
    return repos;
  }

  async checkProject(project, user) {
    const apiEvidence = [];

    let url =
      `${BASE_URL}/rest/api/1.0/projects/${project}/permissions/users?filter=${user}`;
    let d = await this.bb.get(url);
    apiEvidence.push({ endpoint: url, matched: !!d?.values?.length });

    if (d?.values?.length) {
      return {
        hasAccess: true,
        level: this.best(d.values.map(v => v.permission)),
        source: 'PROJECT_USER',
        apiEvidence
      };
    }

    url = `${BASE_URL}/rest/api/1.0/projects/${project}/permissions/groups`;
    d = await this.bb.get(url);
    apiEvidence.push({ endpoint: url, matched: false });

    for (const g of d?.values || []) {
      if (await this.inGroup(g.group.name, user)) {
        apiEvidence[apiEvidence.length - 1].matched = true;
        return {
          hasAccess: true,
          level: g.permission,
          source: 'PROJECT_GROUP',
          apiEvidence
        };
      }
    }

    const repos = await this.getRepos(project);

    for (const r of repos) {
      const ru =
        `${BASE_URL}/rest/api/1.0/projects/${project}/repos/${r.slug}/permissions/users?filter=${user}`;
      const rd = await this.bb.get(ru);
      apiEvidence.push({ endpoint: ru, matched: !!rd?.values?.length });

      if (rd?.values?.length) {
        return {
          hasAccess: true,
          level: this.best(rd.values.map(v => v.permission)),
          source: `REPO_USER:${r.slug}`,
          apiEvidence
        };
      }
    }

    for (const r of repos) {
      const rg =
        `${BASE_URL}/rest/api/1.0/projects/${project}/repos/${r.slug}/permissions/groups`;
      const gd = await this.bb.get(rg);
      apiEvidence.push({ endpoint: rg, matched: false });

      for (const g of gd?.values || []) {
        if (await this.inGroup(g.group.name, user)) {
          apiEvidence[apiEvidence.length - 1].matched = true;
          return {
            hasAccess: true,
            level: g.permission,
            source: `REPO_GROUP:${r.slug}`,
            apiEvidence
          };
        }
      }
    }

    return { hasAccess: false, apiEvidence };
  }
}

/* ================= MAIN ================= */

(async function main() {
  logger.info('Audit started');

  /* -------- STEP 1: Excel → Unique User SSO -------- */

  const wb = xlsx.readFile(INPUT_XLSX);
  const ws = wb.Sheets[wb.SheetNames[0]];
  const rows = xlsx.utils.sheet_to_json(ws, { defval: '' });

  if (!rows.length) {
    logger.error('❌ Excel file is empty');
    process.exit(1);
  }

  const uniqueMap = new Map();

  rows.forEach(r => {
    const user = trim(r['User SSO']);
    if (user && !uniqueMap.has(user)) {
      uniqueMap.set(user, r);
    }
  });

  const uniqueRows = Array.from(uniqueMap.values());

  fs.writeFileSync(
    UNIQUE_CSV,
    Object.keys(uniqueRows[0]).join(',') + '\n'
  );

  uniqueRows.forEach(r => {
    fs.appendFileSync(
      UNIQUE_CSV,
      Object.values(r)
        .map(v => `"${String(v).replace(/"/g, '""')}"`)
        .join(',') + '\n'
    );
  });

  logger.info(`Written ${UNIQUE_CSV}`);

  /* -------- STEP 2: extracted_data.csv -------- */

  fs.writeFileSync(EXTRACTED_CSV, 'User SSO,Account ID,Project Key\n');

  uniqueRows.forEach(r => {
    const project = extractProjectKey(r['Entitlement Desription']);
    fs.appendFileSync(
      EXTRACTED_CSV,
      [
        trim(r['User SSO']),
        trim(r['Account ID']),
        project
      ].join(',') + '\n'
    );
  });

  logger.info(`Written ${EXTRACTED_CSV}`);

  /* -------- STEP 3: Access Audit -------- */

  fs.writeFileSync(
    ACCESS_OUTPUT_CSV,
    'Username,Account ID,Project,Access Status,Level,Source,Timestamp,Screenshot\n'
  );
  fs.writeFileSync(
    NO_ACCESS_OUTPUT_CSV,
    'Username,Account ID,Project,Access Status,Level,Source,Timestamp,Screenshot\n'
  );

  const extractedRows = fs.readFileSync(EXTRACTED_CSV, 'utf8')
    .split('\n')
    .slice(1)
    .filter(Boolean)
    .map(l => {
      const [user, accountId, project] = l.split(',');
      return {
        user: trim(user),
        accountId: trim(accountId),
        project: trim(project)
      };
    })
    .filter(r => {
      if (!r.project) {
        logger.warn(`⚠️ Skipping ${r.user} — empty Project Key`);
        return false;
      }
      return true;
    });

  const bb = new BitbucketClient();
  const resolver = new PermissionResolver(bb);

  const browser = await puppeteer.launch({ headless: true });
  const page = await browser.newPage();

  for (const r of extractedRows) {
    logger.info(`Checking access | ${r.user} | ${r.project}`);

    const res = await resolver.checkProject(r.project, r.user);

    const pngPath = path.join(
      res.hasAccess ? HAS_ACCESS_PNG_DIR : NO_ACCESS_PNG_DIR,
      `${r.user}_${r.project}_${safeTsIST()}.png`
    );

    await page.setContent(`
      <html><body>
      <table id="evidence-table" border="1" cellpadding="6">
        <tr><td>User</td><td>${r.user}</td></tr>
        <tr><td>Account ID</td><td>${r.accountId}</td></tr>
        <tr><td>Project</td><td>${r.project}</td></tr>
        <tr><td>Has Access</td><td>${res.hasAccess}</td></tr>
        <tr><td>Level</td><td>${res.level || '-'}</td></tr>
        <tr><td>Source</td><td>${res.source || '-'}</td></tr>
        <tr><td>Timestamp</td><td>${tsIST()}</td></tr>
        <tr><td>API Evidence</td><td><pre>${JSON.stringify(res.apiEvidence, null, 2)}</pre></td></tr>
      </table>
      </body></html>
    `);

    const table = await page.$('#evidence-table');
    await table.screenshot({ path: pngPath, padding: 15 });

    fs.appendFileSync(
      res.hasAccess ? ACCESS_OUTPUT_CSV : NO_ACCESS_OUTPUT_CSV,
      [
        r.user,
        r.accountId,
        r.project,
        res.hasAccess ? 'HAS_ACCESS' : 'NO_ACCESS',
        res.level || '',
        res.source || '',
        tsIST(),
        pngPath
      ].join(',') + '\n'
    );
  }

  await browser.close();
  logger.info('Audit completed successfully');
})();
